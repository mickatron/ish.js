{"version":3,"sources":["ish.lite.js"],"names":["ish","document","window","$","isNode","o","Node","nodeType","nodeName","extendProp","targetObject","toMerge","prop","propValue","undefined","constructor","Object","Array","isArray","extend","ishObject","forEach","createElement","selector","context","forceSelector","found","length","nodesFound","i","querySelectorAll","el","push","obj","create","n","fn","nth","int","this","scope","s","len","call","indexOf","needle","item","attr","name","value","returnVal","setAttribute","getAttribute","args","arguments","newArray","e","allKeys","getOwnPropertyNames","keyInx","splice","each","offset","ol","ot","offsetParent","offsetLeft","offsetTop","left","top","dimension","type","margins","excludeScrollBar","disp","target","style","display","height","mt","mb","css","outerHeight","outerWidth","clientHeight","clientWidth","offsetHeight","offsetWidth","typeStr","slice","toLowerCase","parseInt","getComputedStyle","getPropertyValue","$el","on","event","delegate","node","matches","mozMatchesSelector","webkitMatchesSelector","oMatchesSelector","matchesSelector","elements","match","delegates","temp","f","delegateTarget","addEventListener","off","removeEventListener","evtfn","trigger","data","createEvent","initEvent","eventName","dispatchEvent"],"mappings":"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","file":"ish.lite.min.js","sourcesContent":["\r\nvar ish = function(document, window, $) {\r\n  'use strict';\r\n  /* Lib core\r\n  ---------------------------------------*/\r\n  var ishObject = {},\r\n  \tforEach = 'forEach',\r\n  \textend = 'extend',\r\n  \t_window = window,\r\n  \t_doc = document,\r\n  \tdummy = document.createElement('i');\r\n  \r\n  \r\n  /**\r\n   * Simple selector engine based on <code>querySelectorAll</code>. The usage and result is similar to <code>jQuery(selector)</code>.\r\n   * @name  ish\r\n   * @augments ishObject\r\n   * @function\r\n   * @memberof ish\r\n   * @param   {String|Node}   selector   A CSS Selector compatible with document.querySelectorAll or a single `Node`.\r\n   * @param   {ishObject|Array|NodeList|Node} context  Used to give a selector a search context.\r\n   * @param   {String} forceSelector    Set the ish('selector').selector paramter forcibly.\r\n   * @return  {ishObject}                A list of nodes with inherited library methods.\r\n   * @example\r\n   * ish('selector');\r\n   * //filter the collection with some context of type Node || NodeList\r\n   * ish('selector', Node);\r\n   * ish('selector', NodeList);\r\n   */\r\n  var $ = function(selector, context, forceSelector) {\r\n  \tcontext = context || document;\r\n  \r\n  \tvar found;\r\n  \tif (isNode(selector) || selector === window || selector === document) {\r\n  \t\tfound = [selector];\r\n  \t\tselector = forceSelector || selector;\r\n  \t} else {\r\n  \t\t// if context is an ishObject\r\n  \t\tif (context.length) {\r\n  \t\t\tfound = [];\r\n  \t\t\tvar nodesFound;\r\n  \t\t\tfor (var i = 0; i < context.length; i++) {\r\n  \t\t\t\tnodesFound = context[i].querySelectorAll(selector || '☺');\r\n  \t\t\t\t// might be able to improve this....\r\n  \t\t\t\t// https://blog.jscrambler.com/12-extremely-useful-hacks-for-javascript\r\n  \t\t\t\tfor (var el = 0; el < nodesFound.length; el++) {\r\n  \t\t\t\t\tfound.push(nodesFound[el]);\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t} else {\r\n  \t\t\t// querySelectorAll requires a string with a length\r\n  \t\t\t// otherwise it throws an exception\r\n  \t\t\tfound = context.querySelectorAll(selector || '☺');\r\n  \t\t}\r\n  \t}\r\n  \tvar length = found.length;\r\n  \tvar obj = Object.create(ishObject);\r\n  \r\n  \tfor (var n = 0; n < length; n++) {\r\n  \t\tobj[n] = found[n]; // || found;\r\n  \t}\r\n  \r\n  \t/**\r\n  \t * The number of items found in the collection.\r\n  \t * @memberOf ishObject\r\n  \t * @name  length\r\n  \t */\r\n  \tobj.length = length;\r\n  \t/**\r\n  \t * The selector string as given when calling ish(selector, context, forceSelector). This value can be overridden if using the ish() forceSelector parameter.\r\n  \t * @memberOf ishObject\r\n  \t * @name  selector\r\n  \t */\r\n  \r\n  \tobj.selector = selector;\r\n  \t/**\r\n  \t * The context as given when calling ish(selector, context).\r\n  \t * @memberOf ishObject\r\n  \t * @name  context\r\n  \t */\r\n  \tobj.context = context;\r\n  \treturn obj;\r\n  };\r\n  \r\n  /**\r\n   * An object which stores prototype objects.\r\n   * @memberOf ish\r\n   * @name  ish.fn\r\n   */\r\n  $.fn = {\r\n  \t/**\r\n  \t * @mixin ish.fn.ishObject\r\n  \t * @property {Number} length \tThe number of items returned in the collection.\r\n  \t * @property {Number} context \tThe context item passed to the ish() selector engine.\r\n  \t * @property {String} selector \tThe selector string passed to the ish() selector engine.\r\n  \t * \r\n  \t * @description\r\n  \t * When you invoke the `ish('selector')` method `ish.fn.ishObject` members are inherited through Prototype Delegation to the returned collection.\r\n  \t * The result is just like a jQuery Object, there is utility methods, a length, context and selector property.\r\n  \t * \r\n  \t * @example\r\n  \t * // Cache an ishObject collection\r\n  \t * var collection = ish('selector');\r\n  \t * \r\n  \t * // Call an ishObject method\r\n  \t * ish('selector').attr('attributeName');\r\n  \t * \r\n  \t * // There is a length property\r\n  \t * ish('selector').length; \r\n  \t * \r\n  \t * // and also a selector property which refers to the first parameter passed into ish();\r\n  \t * ish('selector').selector;\r\n  \t *\r\n  \t * // You can call native methods on collection items just like you would in jQuery\r\n  \t * ish('selector')[0].style.display = 'block';\r\n  \t * \r\n  \t */\r\n  \tishObject: ishObject\r\n  };\r\n  \r\n  //Returns true if it is a DOM node\r\n  function isNode(o) {\r\n  \treturn (\r\n  \t\ttypeof Node === \"object\" ? o instanceof Node :\r\n  \t\to && typeof o === \"object\" && typeof o.nodeType === \"number\" && typeof o.nodeName === \"string\"\r\n  \t);\r\n  }\r\n  \r\n  /**\r\n   * Returns the item at the specified index in the `ishObject`.\r\n   * @name  ish.fn.ishObject.nth\r\n   * @function\r\n   * @param  {Number} int    The index of the item in the `ishObject`.\r\n   * @example\r\n   * ish('selector').nth(0); //gets the first node\r\n   */\r\n  \r\n  ishObject.nth = function(int) {\r\n  \treturn $(this[int], null, this.selector);\r\n  };\r\n  \r\n  \r\n  \r\n  /**\r\n   * Iterates an `ishObject` returning each `Node` in an individual `ishObject`, along with its index \r\n   * in the original collection. This method will iterate every item in the collection and cannot be broken.\r\n   * @name  ish.fn.ishObject.forEach\r\n   * @function\r\n   * @param  {Function} fn    The callback function which will be called with each iteration\r\n   * @param  {Object}   scope The scope in which the callback function will be called. \r\n   * @return {ishObject}        Returns the `ishObject` which called it. Method is chainable. \r\n   * @example\r\n   * ish('selector', function( $item, index ) {\r\n   *     //iterates the collections Dom Nodes, cannot be broken out of.    \r\n   * });\r\n   */\r\n  ishObject[forEach] = function(fn, scope) {\r\n  \tscope = scope || this;\r\n  \tvar i = 0,\r\n  \t\ts,\r\n  \t\tlen = this.length;\r\n  \tfor (i; i < len; i++) {\r\n  \t\ts = $(this[i], null, this.selector);\r\n  \t\tfn.call(scope, s, i);\r\n  \t}\r\n  \treturn this;\r\n  };\r\n  /**\r\n   * Gets the index of a specific `Node` in an `ishObject`\r\n   * @name  ish.fn.ishObject.indexOf\r\n   * @function\r\n   * @param  {Node} needle    The `Node` to find in the `ishObject`.\r\n   * @return {Number}         Index of the `Node` in the `ishObject`. Returns -1 if not found.\r\n   * @example\r\n   * ish('selector').indexOf(Node);\r\n   */\r\n  ishObject.indexOf = function(needle) {\r\n  \tvar i = 0,\r\n  \t\tlen = this.length;\r\n  \r\n  \tfor (i; i <= len; i++) {\r\n  \t\tvar item = this[i];\r\n  \t\tif (item === needle) {\r\n  \t\t\treturn i;\r\n  \t\t} else if (!item) {\r\n  \t\t\treturn -1;\r\n  \t\t}\r\n  \t}\r\n  \t//return this;\r\n  };\r\n  /**\r\n   * Gets an attributes value for the first element in the `ishObject`. If the second argument is supplied the \r\n   * method sets an attribute and its value on all `Node`'s in the given `ishObject`. Prototyped method and properties are shadowed in the new object.\r\n   * @name  ish.fn.ishObject.attr\r\n   * @function\r\n   * @param  {String} name        A valid CSS attribute selector.\r\n   * @param  {String} value       The attirbute value to be set.\r\n   * @return {ishObject|String}     If setting an attribute the method returns the `ishObject` which called it \r\n   * and is chainable. If getting an attribute value the method will return the value found or undefined if \r\n   * it's not found.\r\n   * @example\r\n   * ish('selector').attr('attribute-name'); //get an attribute value\r\n   * ish('selector').attr('attribute-name','attribute-value'); //set an attribute value\r\n   */\r\n  ishObject.attr = function(name, value) {\r\n  \tvar returnVal;\r\n  \tif (typeof value === \"string\") {\r\n  \t\tthis[forEach](function(el) {\r\n  \t\t\tel[0].setAttribute(name, value);\r\n  \t\t});\r\n  \t\treturnVal = this;\r\n  \t} else if (this[0]) {\r\n  \t\treturnVal = this[0].getAttribute(name);\r\n  \t}\r\n  \treturn returnVal;\r\n  };\r\n  \r\n  /**\r\n   * Accepts a series objects, merging the second parameter into the first recursively, if more than two objects are supplied the other objects are merged into the first in the order given.\r\n   * @name  ish#extend\r\n   * @function\r\n   * @param  {Object} object1 An `Object` that will have values of object2 recursively merged.\r\n   * @param  {Object} [,obectj2] A series of `Objects` to merge into object1.\r\n   * @return {Object}         A merged `Object`.\r\n   * @example\r\n   * var obj1 = {a:'a',b:{ba:'ba',bb:'bb',bc:{bca:'bca'}},c:[1,2,3]};\r\n   * var obj2 = {d:'d',b:{ba:'ba-change',bc:{bcb:'added'}},c:[4,5,6]};\r\n   * ish.extend(obj1,obj2);\r\n   */\r\n  \r\n  function extendProp (targetObject, toMerge, prop){\r\n  \tvar propValue = toMerge[prop];\r\n  \tif (propValue === null || propValue === undefined) {\r\n  \t\treturn; // skip null and undefined values\r\n  \t} else if (propValue.constructor === Object || Array.isArray(propValue)) { // recurse objects that already exisit on the target\r\n  \t\ttargetObject[prop] = $[extend](targetObject[prop] || {}, propValue);\r\n  \t} else {\r\n  \t\t/*var descriptor = Object.getOwnPropertyDescriptor(targetObject, prop);\r\n  \t\tconsole.log('descriptor ',prop, descriptor, (typeof descriptor !== 'undefined' && descriptor.writable === 'true'), !targetObject[prop] );\r\n  \t\t\r\n  \t\tif((typeof descriptor !== 'undefined' && typeof descriptor.set !== 'undefined') || !targetObject[prop]) {\r\n  \t\t\tconsole.log('extend ',prop);\r\n  \t\t\ttargetObject[prop] = propValue;\r\n  \t\t}*/\r\n  \r\n  \t\ttargetObject[prop] = propValue;\r\n  \t}\r\n  }\r\n  $[extend] = function() {\r\n  \tvar args = arguments;\r\n  \tvar targetObject = args[0];\r\n  \t// TODO: I dont think this will copy over any constructor prototypes implementations...\r\n  \t// TODO: should I consider shallow copies?\r\n  \tfor (var i = 1; i < args.length; i++) {\r\n  \t\tvar toMerge = args[i];\r\n  \t\tif(Array.isArray(targetObject)){\r\n  \t\t\tvar newArray = [];\r\n  \t\t\tfor (var e = 0; e < toMerge.length; e++) {\r\n  \t\t\t\tif (toMerge[e] === null || toMerge[e] === undefined) {\r\n  \t\t\t\t\tcontinue; // skip null and undefined values\r\n  \t\t\t\t} else if (toMerge[e].constructor === Object ){ \r\n  \t\t\t\t\tnewArray[e] = $[extend](newArray[e] || {}, toMerge[e]);\r\n  \t\t\t\t} else if ( Array.isArray( toMerge[e])) {\r\n  \t\t\t\t\tnewArray[e] = $[extend](newArray[e] || [], toMerge[e]);\r\n  \t\t\t\t} else {\r\n  \t\t\t\t\ttargetObject[e]  = toMerge[e];\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t} else if(targetObject.constructor === Object){\r\n  \t\t\t// all keys incuding non-enums\r\n  \t\t\tvar allKeys = Object.getOwnPropertyNames(toMerge);\t\t\t\r\n  \t\t\tfor (var prop in toMerge) {\r\n  \t\t\t\tvar keyInx = allKeys.indexOf(prop);\r\n  \t\t\t\tallKeys.splice(keyInx, 1);\r\n  \t\t\t\textendProp (targetObject, toMerge, prop);\r\n  \t\t\t}\r\n  \t\t\t// extend any non-enumerable props left over\r\n  \t\t\tfor (var each = 0; each < allKeys.length; each++) {\r\n  \t\t\t\textendProp (targetObject, toMerge, allKeys[each]);\r\n  \t\t\t}\r\n  \t\t}\r\n  \t}\r\n  \treturn targetObject;\r\n  };\r\n  \r\n  /**\r\n   * Returns the left and top offset in pixels for the first element in the `ishObject`. \r\n   * @name  ish.fn.ishObject.offset\r\n   * @function\r\n   * @return {Object}         An `Object` with values for left and top offsets in pixel values.\r\n   * @example\r\n   * ish('selector').offset();\r\n   */\r\n  ishObject.offset = function() {\r\n  \tvar ol = 0;\r\n  \tvar ot = 0;\r\n  \tif (this[0].offsetParent) {\r\n  \r\n  \t\tol = this[0].offsetLeft;\r\n  \t\tot = this[0].offsetTop;\r\n  \r\n  \t}\r\n  \treturn {\r\n  \t\tleft: ol,\r\n  \t\ttop: ot\r\n  \t};\r\n  };\r\n  \r\n  /**\r\n   * Gets the width or height the first element in the supplied `ishObject`.\r\n   * @name  ish.fn.ishObject.dimension\r\n   * @function\r\n   * @param  {String} type          'width' or 'height'.\r\n   * @param  {Boolean} margins      Include margins in the return result.\r\n   * @param  {Boolean} excludeScrollBar Exclude the scrollbars width/height from the result.\r\n   * @return {Integer}              The height of the element.\r\n   * @example\r\n   * ish('selector').width();\r\n   */\r\n  ishObject.dimension = function(type, margins, excludeScrollBar) {\r\n  \tvar disp;\r\n  \tvar target = this[0];\r\n  \tif (this.selector !== (window || document)) {\r\n  \t\tdisp = target.style.display;\r\n  \t\tif (disp === 'none') target.style.display = 'block';\r\n  \t}\r\n  \tvar height = 0;\r\n  \tvar mt = 0;\r\n  \tvar mb = 0;\r\n  \tif (margins) {\r\n  \t\tmt = type === 'height' ? this.css('marginTop') : this.css('marginLeft');\r\n  \t\tmb = type === 'height' ? this.css('marginBottom') : this.css('marginRight');\r\n  \t\theight = mt + mb;\r\n  \t}\r\n  \tif (target === window) {\r\n  \t\theight += type === 'height' ? target.outerHeight : target.outerWidth;\r\n  \t} else if (excludeScrollBar) {\r\n  \t\theight += type === 'height' ? target.clientHeight : target.clientWidth;\r\n  \t} else {\r\n  \t\theight += type === 'height' ? target.offsetHeight : target.offsetWidth;\r\n  \t}\r\n  \tif (this.selector !== (window || document) && disp === 'none') {\r\n  \t\ttarget.style.display = 'none';\r\n  \t}\r\n  \treturn height;\r\n  };\r\n  \r\n  /**\r\n   * Gets the CSS value of the first element in the supplied `ishObject`. Or sets the CSS value on all items in an `ishObject`.\r\n   * @name  ish.fn.ishObject.css\r\n   * @function\r\n   * @param  {String} prop   The name of the CSS property in camelCase. eg. 'margin-left' would be passed as 'marginLeft'.  \r\n   * @param  {String} value   Exclude the horizontal scrollbars height from the result.\r\n   * @return {ishObject}       Returns the `ishObject` which called it. Method is chainable. \r\n   * @example\r\n   * ish('selector').css();\r\n   */\r\n  ishObject.css = function(prop, value) {\r\n  \tif(typeof prop === 'object') {\r\n  \t\tfor(var each in prop) {\r\n  \t\t\tthis.css(each, prop[each]);\r\n  \t\t}\r\n  \t} else if (!value) {\r\n  \t\t//get the style\r\n  \t\tvar typeStr = prop.slice(0, 6) + '-' + prop.slice(6).toLowerCase();\r\n  \t\treturn parseInt(this[0].style[prop] || window.getComputedStyle(this[0]).getPropertyValue(typeStr));\r\n  \t} else {\r\n  \t\t// set the style\r\n  \t\tthis[forEach](function($el) {\r\n  \t\t\t$el[0].style[prop] = value;\r\n  \t\t});\r\n  \t}\r\n  \treturn this;\r\n  };\r\n  //=require ish.core.js\r\n  /**\r\n   * Attach handlers to the Node/s in the given ishObject. This method is just a wrapper for 'addeventListener' so any valid Javascript event can be used. \r\n   * It's inclusion in the library is intended to save you writing loops to cover multiple event targets when hooking events.\r\n   * @name  ish.fn.ishObject.on\r\n   * @function\r\n   * @param  {String}   event     The type of event you're adding to the Node/s\r\n   * @param  {Function} fn        A callback to be fired when the event is triggered.\r\n   * @param  {String}   delegate  A valid CSS selector to delegate the event to.\r\n   * @return {ishObject}            Method is chainable, returns the ish Object which called the method. \r\n   * @example\r\n   * var fn = function(event) {\r\n   *     //mousedown event\r\n   * };\r\n   * ish('selector').on('mousedown', fn);\r\n   */\r\n  \r\n  ishObject.on = function(event, fn, delegate) {\r\n  \r\n  \tif (delegate) {\r\n  \t\tthis[forEach](function(el) {\r\n  \t\t\tvar node = el[0];\r\n  \t\t\tvar matches = node.mozMatchesSelector || node.webkitMatchesSelector || node.oMatchesSelector || node.matchesSelector || (function(delegate) {\r\n  \r\n  \t\t\t\tvar target = node,\r\n  \t\t\t\t\telements = $(delegate),\r\n  \t\t\t\t\tmatch = false;\r\n  \t\t\t\telements[forEach](function($el) {\r\n  \t\t\t\t\tif ($el[0] === target) match = true;\r\n  \t\t\t\t});\r\n  \t\t\t\treturn match;\r\n  \t\t\t});\r\n  \t\t\t//store an array on the node with the delgate function data.\r\n  \t\t\t// we'll call on this data in the undelgate methods\r\n  \t\t\tnode.delegates = node.delegates || [];\r\n  \t\t\tvar temp = {\r\n  \t\t\t\tf: fn,\r\n  \t\t\t\te: function(event) {\r\n  \t\t\t\t\tif (matches.call(event.target, delegate)) {\r\n  \t\t\t\t\t\tevent.delegateTarget = this;\r\n  \t\t\t\t\t\tfn.call(this,event);\r\n  \t\t\t\t\t}\r\n  \t\t\t\t}\r\n  \t\t\t};\r\n  \t\t\tnode.delegates.push(temp);\r\n  \t\t\tnode.addEventListener(event, temp.e);\r\n  \t\t});\r\n  \t} else {\r\n  \t\tthis[forEach](function(el) {\r\n  \t\t\tel[0].addEventListener(event, fn, false);\r\n  \t\t}, this);\r\n  \t}\r\n  \treturn this;\r\n  };\r\n  \r\n  \r\n  /**\r\n   * Dettach handlers to the Node/s in the given ishObject. This method is just a wrapper for 'removeEventListener' so any valid Javascript event can be used. \r\n   * Its inclusion in the library is intended to save you writing loops to cover multiple event targets when hooking events.\r\n   * @name  ish.fn.ishObject.off\r\n   * @function\r\n   * @param  {string} event The type of event you're adding to the Node/s\r\n   * @param  {function} fn The Node to find in the ish Object.\r\n   * @return {ishObject}         Method is chainable, returns the ish Object which called the method. \r\n   * @example\r\n   * var fn = function(event) {\r\n   *     //mousedown event\r\n   * };\r\n   * ish('selector').on('mousedown', mousedownHandler); //on\r\n   * ish('selector').off('mousedown', fn); //off\r\n   */\r\n  ishObject.off = function(event, fn) {\r\n  \r\n  \tthis[forEach](function(el) {\r\n  \t\t// remove listeners from the element\r\n  \t\tel[0].removeEventListener(event, fn, false);\r\n  \t\t// remove any delegate listeners\r\n  \t\tvar delegates = el[0].delegates;\r\n  \t\t// if there's delegates loop each of them\r\n  \t\tif (delegates)\r\n  \t\t\tdelegates[forEach](function(evtfn, i) {\r\n  \t\t\t\t// check for matches\r\n  \t\t\t\tif (evtfn.f === fn) {\r\n  \t\t\t\t\tel.off(event, evtfn.e);\r\n  \t\t\t\t\tel[0].delegates.splice(i - 1, i);\r\n  \t\t\t\t}\r\n  \t\t\t}, this);\r\n  \t});\r\n  \r\n  \treturn this;\r\n  };\r\n  \r\n  \r\n  /**\r\n   * Triggers an event.\r\n   * @name  ish.fn.ishObject.trigger\r\n   * @function\r\n   * @param  {string} type The type of event to trigger.\r\n   * @param  {object} data Any \r\n   * @return {ishObject}         Method is chainable, returns the ish Object which called the method. \r\n   * @example\r\n   * var fn = function(event) {\r\n   *     //mousedown event\r\n   * };\r\n   * ish('selector').on('mousedown', fn); //on\r\n   * ish('selector').trigger('mousedown'); //fires mousedown\r\n   */\r\n  ishObject.trigger = function(type, data) {\r\n  \tthis[forEach](function(el) {\r\n  \t\t// construct an HTML event. This could have\r\n  \t\t// been a real custom event\r\n  \t\tvar event = document.createEvent('HTMLEvents');\r\n  \t\tevent.initEvent(type, true, true);\r\n  \t\tevent.data = data || {};\r\n  \t\tevent.eventName = type;\r\n  \t\t//event.target = el;\r\n  \t\tel[0].dispatchEvent(event);\r\n  \r\n  \r\n  \t\t//el[trigger](event);\r\n  \t});\r\n  \treturn this;\r\n  };\r\n\r\n  return $;\r\n\r\n}(document, this);"]}